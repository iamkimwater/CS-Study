## **OS (운영체제)**

### **효율적이고 빠른 프로그램**

#### **Q. 어떻게 하면 프로그램이 더 효율적으로 동작할까?**

* **블로킹, 논블로킹 방식의 코드 흐름**
	- `블로킹` : OS가 I/O 집약적인 작업이 완료되었다고 알려줄 때까지 CPU는 계산을 미루는 방식
		- 장점 : 코드가 진행되는데 아무런 문제가 없지만
		- 단점 : 비효율적

	- `논블로킹` : OS가 I/O 집약적인 작업이 완료되었다고 알려주는 것과 무관하게 CPU는 자신의 계산을 계속 진행하는 방식
		- 장점 : 효율적이지만
		- 단점 : 코드가 진행되는데 문제가 발생할 수 있음 (필요한 코드가 아직 없을 때 진행될 수 없음)
		- 해결법 : 제어권 흐름을 제어 -> `코루틴` 사용

* **sync, async 방식의 코드 흐름**
	- `sync` : CPU쪽에서 OS에게 I/O 작업 완료 여부를 주기적으로 질문하는 방식
		- 단점 : 주기적으로 확인해야 하기 때문에 비효율적

	- `async` : I/O 작업쪽에서 작업 완료 여부를 이벤트를 통해 OS에게 알려주면 OS가 CPU에게 인터럽트를 걸어서 작업 완료 여부를 알려주는 방식
		- 장점 : 작업 완료 후에 알려주기 때문에 효율적

* 4가지 방식 코드 흐름 조합
	- `블로킹` 하라는 과제는 안하고 엽떡이 오기를 기다리는데 `sync` 계속 os에게 io 친구 어디쯤 왔는지 확인하는 방식
	- `논블로킹` 과제를 계속 진행하면서 `sync` 계속 os에게 io 친구 어디쯤 왔는지 확인하는 방식 `코루틴` 엽떡이 필요한 과제가 존재하는 경우 엽떡을 사 오면 그 부분만 나중에 따로 진행할 수 있도록 함
	- `블로킹` 하라는 과제는 안하고 엽떡이 오기를 기다리는데 `async` io 친구가 엽떡을 사오면 os가 알려준다
	- `논블로킹` 과제를 계속 진행하면서 `async` io 친구가 엽떡을 사오면 os가 알려준다 `코루틴` 엽떡이 필요한 과제가 존재하는 경우 엽떡을 사 오면 그 부분만 나중에 따로 진행할 수 있도록 함













<details>
<summary>참고</summary>

* 명령어
	- CPU 집약적 : 계산, ...
	- I/O 집약적 : 파일 읽기, 통신, ...

* 

</details>